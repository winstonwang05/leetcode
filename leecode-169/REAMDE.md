# 169.多数元素

# 思路一：暴力枚举

```java
package com.leetcode;
// 暴力枚举
public class SolutionOne {
    public int majorityElement(int[] nums) {
        // 设置全局最大
        int MaxCount = 0;
        int candidate = nums[0];
        // 遍历最外层
        for (int i = 0; i < nums.length; i++) {
            // 设置当前元素的个数
            int curCount = 1;
            for (int j = i + 1; j < nums.length; j++) {
                // 如果遇到相同则 +1
                if (nums[j] == nums[i]) {
                    curCount++;
                }
            }
            // 遍历结束更新全局最大，并且记录此时最大对应的索引元素
            if (curCount > MaxCount) {
                MaxCount = curCount;
                candidate = nums[i];
            }
        }
        return candidate;
    }
}

```

# 思路二：哈希表存储

```java
class Solution {
    public int majorityElement(int[] nums) {
        // 初始化哈希表
        Map<Integer, Integer> map = new HashMap<>();
        int n = nums.length;
        for (int num : nums) {
            // 如果存在，value + 1
            /*if (map.containsKey(num)) {
                map.put(num, map.get(num) + 1);
            } else {
                map.put(num, 1);
            }*/
            map.put(num, map.getOrDefault(num, 0) + 1);
            if (map.get(num) > n/2) {
                return num;
            }
        }
        return -1;
    }
}
```

map.getOrDefault(num, 0) + 1的用法和上面的if else一样，这里是如果存在这个key就用num， get（num）+1；如果不存在默认取 0 然后加1；

# 思路三：Boyer-Moore 投票算法

## ✅ 完整表述优化版

我的理解是：

> 题目要求找到出现次数超过数组长度一半的元素。因为这个元素数量占多数，所以我们可以用 **Boyer-Moore 投票算法** 来解决问题。
>
> 核心思想是“抵消计数”：
>  不断地将不同的元素两两抵消，最后剩下的那个元素一定是多数元素。

------

### 🧠 实现思路：

1. **初始化两个变量**：

    - `candidate`：候选人元素
    - `count`：当前候选人的计数值

2. **遍历数组**：

    - 如果当前计数为 `0`，说明之前的候选人已经被抵消完了（即之前出现的元素被其他元素平衡掉了），所以更新候选人：

      ```
      candidate = num;
      ```

    - 如果当前元素等于候选人，`count++`；否则 `count--`。

3. **遍历结束后**：

    - 因为多数元素的出现次数大于总长度的一半，所以即使经过抵消，它仍然会留下来，最终 `candidate` 就是多数元素。

------

### ⚙️ 代码实现：

```
public int majorityElement(int[] nums) {
    int count = 0;
    int candidate = 0;

    for (int num : nums) {
        if (count == 0) {
            candidate = num;
        }
        count += (num == candidate) ? 1 : -1;
    }

    return candidate;
}
```

------

### 📘 核心理解总结：

- **为什么可以抵消？**
  因为题目保证多数元素出现次数 > n / 2，所以无论怎么抵消，它最后一定还会剩下。
- **为什么更新候选人是当前元素而不是下一个？**
  因为“计数归零”是当前遍历状态下的结果，表示旧候选人彻底出局，所以立刻让**当前元素**成为新的候选人。
- **最终返回的 candidate 为什么一定正确？**
  因为非多数元素的总次数无法完全抵消掉多数元素的次数，最后剩下的一定是它。

首先题目的要求就是找出出现最多的元素，并且明确了最多的次数超过数组总元素一般，所以我们可以利用投票算法解决：核心就是不断抵消元素个数，如果遍历到的元素个数为0说明该元素与其他元素相比要少；实现：首先需要初始化候选人和数量（通过数量判断来更新候选人）；接着遍历数组，如果此时次数为0，该上一次遍历到的元素个数相比其他要少，所以需要更新候选人为当前遍历到的元素，然后就是对计数的实现，如果是候选人那么就+1，不是就-1；最后遍历结束返回候选人一定是出现次数超过一半的，并且计数肯定是大于0的。在更新候选人是用当前遍历到的元素，不是⚠️下一个元素，因为上一次遍历的元素在最后更新次数为0，那么就将候选人更新当前遍历到的元素



## 💡 一、核心理解：count = 0 意味着“上一个候选人被抵消完了”

在算法执行过程中：

- `count` 记录的是当前候选人相对于其他元素的“净票数”；

- 当 `count == 0` 时，表示：

  > 之前的候选人累计的优势票数已经被其他元素抵消完了，
  >  换句话说——“上一个候选人被淘汰了”。

------

## ⚙️ 二、代码逻辑时序理解

来看代码的关键部分：

```
for (int num : nums) {
    if (count == 0) {
        candidate = num; // ⚠️ 当前元素成为新的候选人
    }
    count += (num == candidate) ? 1 : -1;
}
```

当 `count == 0` 时：

- 意味着前一轮候选人“失去了所有优势”；
- 所以我们让**当前正在遍历的元素**成为新的候选人。

注意这个细节顺序：

| 步骤 | 当前元素             | count状态  | 操作                     |
| ---- | -------------------- | ---------- | ------------------------ |
| 1    | 上一个候选人被抵消完 | count == 0 | 说明上一个候选人出局     |
| 2    | 当前循环遍历到新元素 | —          | 把当前元素设为新的候选人 |
| 3    | 对当前元素进行计数   | count += 1 | 新候选人获得第一票       |

> 🔹 也就是说，**更新候选人发生在“当前元素”这里，不是下一个元素**，
>  因为“计数归零”是在这一轮循环内就已经判断出来的结果。

------

## 📘 举个例子说明

数组：`[2, 2, 1, 1, 1, 2, 2]`

| 元素 | 候选人 | count变化 | 说明                                      |
| ---- | ------ | --------- | ----------------------------------------- |
| 2    | 2      | 1         | 设候选人=2，+1                            |
| 2    | 2      | 2         | 相同+1                                    |
| 1    | 2      | 1         | 不同-1                                    |
| 1    | 2      | 0         | 不同-1 → 归零，候选人被抵消完             |
| 1    | 1      | 1         | ⚠️ 此时 count==0，更新候选人=当前1，然后+1 |
| 2    | 1      | 0         | 不同-1 → 归零                             |
| 2    | 2      | 1         | count==0，更新候选人=当前2，然后+1        |

遍历结束后 `candidate = 2`，即为多数元素。

## ✅ 总结一句话

> “count 归零”代表旧候选人被完全抵消，所以我们在**下一次判断时立刻让当前遍历到的元素成为新的候选人**。
>  换句话说，**更新候选人发生在“归零那一轮”的当前元素，而不是等到下一轮**。