
# 45 跳跃游戏II

```java
class Solution {
    public int jump(int[] nums) {
        int steps = 0;     // 跳跃次数
        int end = 0;       // 当前跳跃能到的最远边界
        int maxPos = 0;    // 下一跳能到的最远位置
        
        for (int i = 0; i < nums.length - 1; i++) {
            maxPos = Math.max(maxPos, i + nums[i]);
            if (i == end) { // 到达当前层的边界
                end = maxPos;
                steps++;
            }
        }
        return steps;
    }
}

```

## 💡再解释一遍总结的核心逻辑

确实所说，这题可以看作是**BFS 层序遍历**在一维数组上的贪心模拟。

我们有三个关键变量：

| 变量名   | 含义                                               |
| -------- | -------------------------------------------------- |
| `steps`  | 跳跃次数（层数）                                   |
| `maxPos` | 当前能跳的“潜在最远位置”（下一层能覆盖的最远范围） |
| `end`    | 当前这次跳跃能到达的最远边界（当前层的右边界）     |

------

## 🧭算法过程（配合你的描述）

1. **从索引 0 开始遍历（不需要遍历到最后一个索引）**
   原因如所说：

    - 题目保证一定能到终点；
    - 当我们到达倒数第二个索引时，`maxPos` 已经更新到终点或更远了，最后一次跳跃已经计入。

2. **更新潜力最远位置**
   每次走一步（即遍历一次 `i`），我们更新：

   ```
   maxPos = max(maxPos, i + nums[i])
   ```

   表示当前步在现有范围中，下一跳可以达到的最远位置。
   👉 你说的“潜力最远”正是这里的 `maxPos`。

3. **触碰当前层边界 → 必须跳一次**
   当 `i == end`，意味着我们走到了这一层的边界：

    - 当前这一跳能到的所有位置已经遍历完了；
    - 下一步再往前走，必须要**进行下一次跳跃**才能继续。

   所以我们：

   ```
   steps++
   end = maxPos
   ```

   同时，`end` 被更新为下一跳能到达的新边界。

4. **不遍历最后一个索引的原因**
   因为我们最后一次更新 `steps` 的时候，`end` 已经被更新到了 `maxPos`，
   而此时 `maxPos >= nums.length - 1`，说明最远范围已经覆盖终点了。
   所以即使不显式遍历最后一个索引，结果仍然正确。

------

## 🔍直观类比：层序遍历 BFS

| BFS 概念       | 本题对应                                 |
| -------------- | ---------------------------------------- |
| 层             | 一次跳跃能覆盖的索引范围                 |
| 节点           | 索引位置                                 |
| 队列扩展下一层 | 更新 `maxPos` 并在到达边界时增加 `steps` |
| 遍历完当前层   | `i == end`                               |
| 进入下一层     | `steps++`, `end = maxPos`                |

说的“每一层相当于边界范围中，不断更新边界最远范围实现次数 +1”正是这个 BFS 层层推进的核心逻辑。

------

## 🧩举例再看

```
nums = [2,3,1,1,4]
```

| i                                    | nums[i] | maxPos | end  | steps | 说明                 |
| ------------------------------------ | ------- | ------ | ---- | ----- | -------------------- |
| 0                                    | 2       | 2      | 0    | 0     | 初始范围只能到 0     |
| **i==end** → 跳一次 → steps=1, end=2 |         |        |      |       |                      |
| 1                                    | 3       | 4      | 2    | 1     | 潜力最远变成 4       |
| 2                                    | 1       | 4      | 2    | 1     | 继续在范围内更新最远 |
| **i==end** → 跳一次 → steps=2, end=4 |         |        |      |       |                      |
| `end=4` 覆盖终点，结束               |         |        |      |       |                      |

结果：`steps=2`

------

## ✅ 总结归纳（这段话的提炼版）

> 我们维护三个变量：
>  `steps` 表示最少跳跃次数，`maxPos` 表示当前范围内能跳到的最远位置（潜力最远），`end` 表示当前跳跃的边界范围。
>  从索引 0 开始，每走一步更新 `maxPos`，当走到当前层的边界 `end` 时，说明必须进行一次新的跳跃，此时将 `end` 更新为 `maxPos`，并令 `steps++`。
>  不必遍历到最后一个索引，因为最后一次跳跃更新时，最远范围已覆盖终点。
>  整体过程就像一维的 BFS 层序遍历，每一层代表一次跳跃范围。

三个变量，一个变量steps表示需要跳的最小次数，一个变量maxPos表示全局能跳的最远，一个变量end表示能够到达的范围边界；遍历数组，条件不需要遍历到最后一个索引也就是终点，原因有二：一是题目中明确说了可以保证能到达终点，二是代码层面的实现：从0索引开始，值就是第一次能跳的范围，在这范围中每走一步需要继续更新能够走的最远（这个就是”潜力最远“），然后如果遍历到了边界的索引位置（也就是遍历到了索引下值表示能够最远位置），这时候必须得跳一次 了，我们初始化的边界是0索引，所以第一次需要将边界更新为最远并且次数+1，必须得跳；这样以来，就算没有到达最后一个索引，到达倒数第二个索引时候边界范围和最远范围已经至少大于等于终点了，并且在最后一次到达边界已经次数+1了，最远已经更新给边界了，虽然遍历还在继续，但是实现了最小次数，为何呢，和层序相似，在每一层就相当于每一个边界范围中，不断更新边界最远范围实现次数加1·

最小次数就是在达到边界必须跳一次，在更新最远距离赋值给边界，这样达到最小次数

