# 198.打家劫舍

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;

        // 边界情况
        if (n == 1) return nums[0]; // 只有一个房子，直接偷
        if (n == 2) return Math.max(nums[0], nums[1]); // 两个房子，偷金额大的那个

        // dp 数组，dp[i] 表示偷到第 i 个房子时的最大金额
        int[] dp = new int[n];
        dp[0] = nums[0]; // 第 0 个房子只能偷它自己
        dp[1] = Math.max(nums[0], nums[1]); // 第 1 个房子，要么偷第 0，要么偷第 1，取最大

        // 状态转移
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        // 最终答案是偷到最后一个房子时的最大金额
        return dp[n - 1];
    }
}

```

## 🧠理解（LeetCode 198 打家劫舍）

题目的意思是：不能偷相邻的房子，也就是说，如果偷了第 `i` 个房子，就不能偷第 `i-1` 个。目标是找到一种方案，使偷到的金币总数最大。

这题明显是一种 **递推关系**，考虑不同情况下的最优选择，因此使用 **动态规划（Dynamic Programming）**。

如果使用贪心算法，只能得到局部最优解（例如每次偷当下最多的房子），但无法保证全局最优；而动态规划则是综合考虑“偷”与“不偷”的所有情况，保证整体最优。

------

### 🧩 实现思路

1. **边界情况：**

    - 如果只有一个房子，只能偷这个房子 → `dp[0] = nums[0]`
    - 如果有两个房子，取两者中金币多的 → `dp[1] = max(nums[0], nums[1])`

2. **动态规划状态定义：**
   `dp[i]` 表示 **到第 i 个房子为止**，能够偷到的最大金额。

3. **状态转移方程：**
   对每个房子有两种选择：

    - 不偷当前房子 → 最大金额是 `dp[i-1]`
    - 偷当前房子 → 不能偷上一个，所以金额是 `dp[i-2] + nums[i]`

   所以：

   ```
   dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
   ```

4. **最终结果：**
   动态数组最后一个元素 `dp[n-1]` 就是能偷到的最大金额。

------

### 🧮 举例说明

以 `nums = [2,7,9,3,1]` 为例：

| i    | nums[i] | 状态计算                | dp[i] |
| ---- | ------- | ----------------------- | ----- |
| 0    | 2       | dp[0] = 2               | 2     |
| 1    | 7       | dp[1] = max(2,7) = 7    | 7     |
| 2    | 9       | dp[2] = max(7,2+9)=11   | 11    |
| 3    | 3       | dp[3] = max(11,7+3)=11  | 11    |
| 4    | 1       | dp[4] = max(11,11+1)=12 | 12    |

最终答案：**12**

✅ **总结一句话：**

> 动态规划核心是“偷 or 不偷”，
>  用状态转移方程 `dp[i] = max(dp[i-1], dp[i-2]+nums[i])` 不断更新最优解。

首先题目的意思就是不能偷相邻房间的金币，必须间隔，中间可以间隔一个或者多个都行，总之就需要偷得到的金币和最大；所以是一种递推的形式，考虑不同情况得到最大值，这里用到的是动态规划，如果是贪心仅是局部最优找最大值，最终结果可能不是全局最优，动态规划就是考虑到了不同情况获取最优；实现：首先需要判断边界情况，如果仅一个房子，肯定之能偷这一个房子，如果是两个房子，取最大的就行了；接着就是动态规划的思想：动态数组中存的值就是累加后的结果，我们需要考虑两种情况，一种是不偷，一种是偷，如果是偷，那么就需要从dp[i - 2] 下的值加上当前遍历到的元素值，因为不能偷相邻的（也就是不能从dp[i - 1]偷）；如果是不偷，就从dp[i - 1]，这里的动态数组下的值是之前累加的结果，将这二者取最大得到偷的最大金币数并赋值到当前遍历到的动态数组索引，因此每一个动态数组下的索引下的值就是之前的累加结果；所以我们需要初始化动态数组，dp[0]表示只有一个房子肯定只能偷nums[0]， dp[1]就需要判断nums[1]和nums[0]取最大，循环从i =2开始；最后打印的就是偷到的最后一个房子最大，因为中间通过不断优化取最大

