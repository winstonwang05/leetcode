# 189.轮转数组

### ✅ 方法一：暴力法（多次旋转）——【思路直观但效率低】

**思路：**
每次将最后一个元素移动到最前面，重复 `k` 次。

**示例：**

```
nums = [1,2,3,4,5,6,7], k=3
第1次：[7,1,2,3,4,5,6]
第2次：[6,7,1,2,3,4,5]
第3次：[5,6,7,1,2,3,4]
```

**复杂度：**

- 时间：O(n × k)
- 空间：O(1)

> k 大时超时。

```java
public void rotate(int[] nums, int k) {
    int n = nums.length;
    k = k % n; // 处理 k 大于数组长度的情况

    for (int i = 0; i < k; i++) {
        int last = nums[n - 1];  // 取出最后一个元素
        // 整体右移一位
        for (int j = n - 1; j > 0; j--) {
            nums[j] = nums[j - 1];
        }
        nums[0] = last; // 把最后一个放到最前
    }
}

```

## 💡 一、为什么「不能从头开始」遍历？

我们来还原逻辑：

暴力法的本质是——

> 每次右移 1 位，让每个元素都去它右边的位置。

------

如果你从 **左到右（从 0 开始）** 遍历：

```
for (int j = 0; j < n; j++) {
    nums[j] = nums[j + 1];
}
```

会有两个问题：

1. ❌ `nums[j + 1]` 最后一次会访问到 `nums[n]` —— 越界；
2. ❌ 覆盖问题：一旦你修改了 `nums[0]`，就破坏了后面要用的原始值（因为它被覆盖了）。

------

## ✅ 二、为什么要「反向遍历」

反向遍历是解决上面两个问题的核心。

当你从 **右到左**：

```
for (int j = n - 1; j > 0; j--) {
    nums[j] = nums[j - 1];
}
```

那么：

- `nums[j - 1]` 总是安全的；
- 已经移动的元素不会被覆盖；
- 不会出现索引越界；
- 最后再单独把保存的“最后一个元素”放到最前。

这就是暴力法最安全、正确的写法 ✅。

------

## 🧠 三、为什么不能从 0 索引开始

你的这句非常关键：

> “因为 0 索引是要和最后一个索引换位置的。”

是的！
如果我们把数组右移一位：

```
[1, 2, 3, 4, 5, 6, 7]
→ [7, 1, 2, 3, 4, 5, 6]
```

可以看到：

- `nums[0]` 的新值来自 **最后一个元素**；
- `nums[n-1]` 的值要先被保存，否则它就丢失了。

因此必须：

1. **先保存最后一个元素；**
2. **再从右向左移动；**
3. **最后再把保存的元素放到 nums[0]。**

------

## ✅ 四、总结结论（非常正确）

| 问题                     | 原因                                          | 正确做法            |
| ------------------------ | --------------------------------------------- | ------------------- |
| 为什么不能从头遍历       | 会越界 (`j+1`)，还会覆盖未移动的数据          | 应该从右往左        |
| 为什么不能从 0 开始      | 第 0 位要和最后一位换位置，必须先保留最后一位 | 从 `n-1` 开始往前走 |
| 为什么要保存最后一个元素 | 移动过程中会被覆盖                            | 先保存再放回        |

### ✅ 方法二：使用额外数组（简洁但不满足“原地修改”）

**思路：**
新建一个临时数组，元素的新位置 = `(i + k) % n`。

**代码：**

```
public void rotate(int[] nums, int k) {
    int n = nums.length;
    int[] temp = new int[n];
    for (int i = 0; i < n; i++) {
        temp[(i + k) % n] = nums[i];
    }
    System.arraycopy(temp, 0, nums, 0, n);
}
```

**复杂度：**

- 时间：O(n)
- 空间：O(n)

> 不符合原地修改要求，但思路清晰。

### ✅ 方法三：反转法（最优解，推荐🔥）

> **核心思想：**
>  三次反转数组，即可实现旋转效果！

假设：

```
nums = [1,2,3,4,5,6,7], k = 3
```

1. 先整体反转 → `[7,6,5,4,3,2,1]`
2. 再反转前 `k` 个元素 → `[5,6,7,4,3,2,1]`
3. 最后反转后 `n-k` 个元素 → `[5,6,7,1,2,3,4]`

✅ 完成轮转。

------

### 💻 实现代码

```
public void rotate(int[] nums, int k) {
    int n = nums.length;
    k = k % n; // 防止 k > n

    reverse(nums, 0, n - 1);      // 1. 反转整个数组
    reverse(nums, 0, k - 1);      // 2. 反转前 k 个
    reverse(nums, k, n - 1);      // 3. 反转后 n-k 个
}

private void reverse(int[] nums, int left, int right) {
    while (left < right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
        left++;
        right--;
    }
}
```