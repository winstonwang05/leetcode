# 560.和为K的子数组

## 方法一：暴力解法：

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            int sum = 0;
            for(int j = i; j < nums.length; j++) {
                sum += nums[j];
                if (sum == k) {
                    count++;
                }
            }
        }
        return count;
    }
}
```

不断实现累加，就算如果数组中的单独一个元素为k，那么累加第一个正好满足

## ⚡方法二、优化思路：前缀和 + 哈希表（核心解法）

核心公式是：

> **`preSum[j] - preSum[i] = k` ⇒ 区间 (i, j] 的和为 k**

即：

- `preSum[j]` 表示从下标 0 到 j 的所有元素的和；
- `preSum[i]` 表示从下标 0 到 i 的所有元素的和；
- 两者相减，就得到了子数组 `(i, j]` 的区间和。

所以问题变成：

> 对于每个位置 `j`，我们要找有多少个 `i` 满足 `preSum[i] = preSum[j] - k`。

这样就能在 **一次遍历中** 统计出所有符合条件的子数组个数。

------

## 🧠 四、代码实现（前缀和 + HashMap）

```
class Solution {
    public int subarraySum(int[] nums, int k) {
        // 用于统计前缀和出现的次数
        Map<Integer, Integer> preSumCount = new HashMap<>();
        preSumCount.put(0, 1); // 前缀和为0出现1次（表示空前缀）

        int preSum = 0;  // 当前的前缀和
        int count = 0;   // 结果计数

        for (int num : nums) {
            preSum += num; // 更新当前前缀和

            // 查找之前有多少前缀和是 preSum - k
            if (preSumCount.containsKey(preSum - k)) {
                count += preSumCount.get(preSum - k);
            }

            // 更新当前前缀和出现次数
            preSumCount.put(preSum, preSumCount.getOrDefault(preSum, 0) + 1);
        }

        return count;
    }
}
```

------

## 🧩 五、关键理解点

| 概念          | 含义                                   |
| ------------- | -------------------------------------- |
| `preSum`      | 从 `nums[0]` 到当前元素的总和          |
| `preSumCount` | 统计每个前缀和出现了几次               |
| `preSum - k`  | 找之前哪个前缀和能让当前子数组的和为 k |

## 🔹你最终的完整理解（优化版）

题目要求统计 **连续子数组的和等于 k** 的个数，因此我们可以用 **哈希表 + 前缀和** 来高效实现。

------

### 一、核心思路

由于是连续的子数组，我们可以定义一个前缀和：

```
preSum[i] = 从数组开头到第 i 个元素的所有元素之和
```

那么任意一段连续子数组 `[j + 1, i]` 的和为：

```
preSum[i] - preSum[j]
```

当这个差值等于 k 时，说明存在一个子数组满足条件。
也就是说，只要在遍历时发现：

```
preSum - k
```

曾经出现过，就说明存在一个或多个前缀，使得当前这一段子数组的和为 k。

------

### 二、哈希表的设计与作用

我们使用哈希表：

```
key = 前缀和 preSum
value = 当前前缀和出现的次数
```

因为不同的下标可能产生相同的前缀和（比如数组中存在负数或 0），所以 **key 可能重复**。
当 key 重复时，我们不覆盖，而是让：

```
value = 原来的 value + 1
```

代表这个前缀和出现了多次（即有多个不同的“起点”可能形成合法子数组）。

------

### 三、算法执行流程

1. 初始化：

    - `preSum = 0` 表示当前的前缀和。
    - `count = 0` 表示全局符合条件的子数组数量。
    - `map.put(0, 1)` 防止第一个子数组本身刚好等于 k 的情况（比如 `[3]`，k=3）。

2. 遍历数组：

    - 每遍历一个元素，都更新当前前缀和：

      ```
      preSum += num
      ```

    - 然后判断：

      ```
      preSum - k
      ```

      是否存在于 map 中。

        - 如果存在，说明以当前索引为终点的子数组中，有若干段的和为 k；

        - 那么就让：

          ```
          count += map.get(preSum - k)
          ```

          因为可能有多个前缀和满足条件。

    - 最后更新当前前缀和出现的次数：

      ```
      map.put(preSum, map.getOrDefault(preSum, 0) + 1)
      ```

3. 遍历完返回 `count`。

------

### 四、关键理解总结（已经掌握了的点 ✅）

- `map` 是前缀和出现次数的统计器；
- `value` 表示当前前缀和出现了几次；
- **key 重复时必须 value++**，因为同一个前缀和可能对应多个起点；
- `count` 是全局计数器，不是单次 +1，而是每次加上所有符合条件的次数；
- 当遇到 `preSum - k` 存在于 map 时，**就一次性把所有对应的 value 加上去**；
- 所以就算 key 重复，`value` 只是正常 +1，全局 `count` 也会在命中时一次性加上对应的 `value`。

------

### 五、举个简单例子巩固

```
nums = [1, 2, 1, 2], k = 3
```

| 步骤   | 当前 num | preSum | preSum - k | map（前缀和出现次数）     | count |
| ------ | -------- | ------ | ---------- | ------------------------- | ----- |
| 初始化 | -        | 0      | -          | {0=1}                     | 0     |
| ①      | 1        | 1      | -2 ❌       | {0=1, 1=1}                | 0     |
| ②      | 2        | 3      | 0 ✅        | {0=1, 1=1, 3=1}           | 1     |
| ③      | 1        | 4      | 1 ✅        | {0=1, 1=1, 3=1, 4=1}      | 2     |
| ④      | 2        | 6      | 3 ✅        | {0=1, 1=1, 3=1, 4=1, 6=1} | 3     |

最终 `count = 3`
对应子数组是 `[1,2]`、`[2,1]`、`[1,2]`（后两个不同起点）。

------

### ✅ 一句话总结（可以写在笔记上）

> **哈希表记录历史前缀和出现次数，当前前缀和命中 preSum - k 时，说明存在若干前缀能组成和为 k 的子数组，count 一次性累加这些出现次数。**

------

这次的总结已经完全到位，只需要把

> “key 不可能相同”
>  改成
>  “key 可能相同，因为数组可能包含负数或 0，重复表示多个不同的起点”
>  就完美无缺了。

用哈希表实现：由于题目的要求是连续的元素和（这个连续元素可以是一个或者连续多个）等于要求的k值，因此我们可以设计key为每次遍历到当前的元素   前面的元素和；value就是对应的前缀出现的次数，可知，由于每次遍历key都是不断累加的，因此key不可能相同，所以value如果key存在相同，就会在原来+1，不存在的key那么value默认就为1，但是我们重点是全局count，所以我们在外界初始化全局的计数器，因此这个value就是为外界的计数器实现每一次+1的；实现：首先需要初始化前缀和，以及计数器都为0，哈希表，但是为了防止空，所以首先需要插入和为0，出现的次数固定为1；接着就是遍历数组，前缀和累加当前遍历到的元素，如果前缀和减去k在map中存在那么就需要更新全局计数器，这里不是count++；是更新全局用全局的计数器加上前缀和对应的value值基本固定为1；然后如果不存在，那么就将当前累加的（包括当前遍历到的元素）和存入key，value默认+1，最后返回全局计数器；我觉得这个算法挺巧妙的：如果是数组中存在一个元素是k，那么它之前的前缀和加上它 再减去 k正好就是上一次的key，所以是存在的，全局计数器+对应的value  ；就算key重复，他的value在原基础上正常+1，全局也就是再上面累加value而已， 也就是一次性加