# 3.无重复字符的最长字串

## 首先理解字串和有序列

### 💡 一句话概括

- **字串（substring）**：
  👉 必须连续，不能跳。
- **子序列（subsequence）**：
  👉 只要顺序一致就行，可以跳着取。

------

### 🔍 举个例子：

原字符串：`"abcde"`

| 类型   | 举例    | 是否符合                 |
| ------ | ------- | ------------------------ |
| 字串   | `"bcd"` | ✅ 连续的                 |
| 字串   | `"ace"` | ❌ 不连续，跳了           |
| 子序列 | `"ace"` | ✅ 顺序没变，但跳了，可以 |
| 子序列 | `"cae"` | ❌ 顺序乱了，不行         |

------

### 🧠 可以这样记：

> **字串 substring** → 连续段
>  **子序列 subsequence** → 按顺序抽取

### 字串必须是连续的，有序列是保证相对位置顺序就行，相当于后者可以跳

# 思路：滑动窗口 + 哈希表

```java
public class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 哈希集合：用于记录当前窗口内的字符
        Set<Character> set = new HashSet<>();
        int left = 0, right = 0, maxLen = 0;

        while (right < s.length()) {
            char c = s.charAt(right);

            // 如果有重复字符，就移动左指针
            while (set.contains(c)) {
                set.remove(s.charAt(left));
                left++;
            }

            // 加入当前字符
            set.add(c);
            // 更新最大长度
            maxLen = Math.max(maxLen, right - left + 1);
            right++;
        }

        return maxLen;
    }
}

```



> **题意理解：**
>  本题要求的是「无重复字符的最长字串」。
>
> 根据定义，**字串（substring）** 必须是一段**连续的字符串**。题目又要求字串中**不出现重复字符**，因此我们要在所有连续的字串中，找到不含重复字符的最长一段。
>
> **思路分析：**
>  因为字串要求连续，所以我们自然想到使用 **滑动窗口（Sliding Window）** 的解法。
>
> 我们需要在滑动过程中同时满足两个条件：
>
> 1. 当前窗口表示一段连续的字串；
> 2. 窗口中不含重复字符。
>
> 因此，我们可以使用一个 `Set` 集合来表示当前窗口中出现过的字符，以保证窗口内元素唯一。
>
> **初始化：**
>
> - 定义一个 `Set<Character>` 集合作为窗口；
> - 定义两个指针 `left` 和 `right`，都指向字符串起点（索引 0）；
> - 定义一个变量 `maxLen` 表示最长字串长度，初始为 0。
>
> **滑动窗口过程：**
>  遍历字符串（通常从左到右）：
>
> - 当右指针所指的字符 **不在** 当前窗口集合中，说明没有重复，
    >    可以将该字符加入窗口，并更新最大长度：
    >
    >   ```
>   maxLen = Math.max(maxLen, right - left + 1)
>   ```
    >
    >   然后继续右移 `right`。
>
> - 当右指针所指的字符 **已经存在** 于当前窗口中，说明出现了重复字符，
    >    我们需要通过移动左指针来“去除重复”。
    >    由于左边不一定就是重复字符的位置，所以我们用一个 **while 循环** 不断移动左指针，并从窗口中移除左边的字符：
    >
    >   ```
>   while (set.contains(s.charAt(right))) {
>       set.remove(s.charAt(left));
>       left++;
>   }
>   ```
    >
    >   当窗口中不再包含重复字符时，循环结束。
    >    此时就可以安全地把新的字符加入窗口。
>
> **为什么要 while 循环？**
>  因为窗口内可能有多个不同字符，而重复字符可能不在最左边，所以要不断地缩小窗口直到重复被移除。
>
> **举例说明（s = "abcb"）：**
>
> ```
> 初始：left=0, right=0, set={}
> 
> right=0 -> 'a' 不重复 → 加入 set={'a'}，max=1
> right=1 -> 'b' 不重复 → 加入 set={'a','b'}，max=2
> right=2 -> 'c' 不重复 → 加入 set={'a','b','c'}，max=3
> right=3 -> 'b' 重复（'b' 已存在）
>     while 循环：
>         移除 left=0 的 'a' -> set={'b','c'}
>         移除 left=1 的 'b' -> set={'c'}
>     循环结束，此时窗口中仅剩下 'c'
>     再加入新的 'b' -> set={'c','b'}
>     更新 max=3
> ```
>
> 遍历完成后，返回 `maxLen = 3`。
>
> **总结：**
>  滑动窗口的核心目标是保持窗口内「无重复」，并在每次窗口更新时动态计算长度。
>  当出现重复字符时，通过左指针的 while 循环不断收缩窗口；
>  当窗口恢复合法状态后，再通过右指针扩张窗口。
>  最终得到的 `maxLen` 就是最长无重复字串的长度。

------

## ✅ 思考点总结

> 「如果是 abcb，窗口中元素有 abc，下次滑动窗口中右指针会遇到相同字符 b，那么就会通过循环不断去除为止，所以说最后仅剩下 c，最后会走下面逻辑将 b 添加到窗口中。」

完全对 ✔️
这正是滑动窗口“先清理重复 → 再扩张右边”的标准动作。



此题要求的是无重复的最长字串，子串是一段连续的字符串中间无重复字符，然后此题是在这基础上再去重后在找最长字串；因为字串要求连续字符，因此我们想到了滑动窗口的解法，由于还需要再这基础上对字串中相同字符去重，然后取最长字串，所以我们的初始化的窗口就是一个Set集合，然后初始化窗口的左右边界线都为字符串0索引位置起点以及最大长度为0（因为后面滑动窗口会更新最长）；因此，开始遍历字符串，逆向更方便，如果在滑动窗口遇到了窗口中字串的相同元素，那么就要去除左边界的第一个元素，并移动左指针，移动之后还会继续判断窗口中是否有相同元素，可以移走的最左并不是重复的，所以这里是一个while循环，为的就是保证窗口无重复性，一旦窗口中字符和遍历到的不同，循环就退出结束；如果是不同元素，那么就添加到窗口中，然后更新最长，将每次遍历得到的窗口中的元素个数之和就是最大，所以是right - left 还需要 +1；然后移动右指针走下去，最后遍历结束；返回最长变量  。有一个点我想到的：如果是abcb，窗口中元素有abc，下次滑动窗口中右指针会遇到相同字符b那么就会通过循环不断去除为止，所以说最后仅剩下c，最后会走下面逻辑将b添加到窗口中

