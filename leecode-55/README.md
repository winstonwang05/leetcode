# 55.跳跃游戏

```java
class Solution {
    public boolean canJump(int[] nums) {
        int maxReach = 0;
        for (int i = 0; i < nums.length; i++) {
            // 如果当前位置不可达
            if (i > maxReach) return false;
            // 更新最远可达位置
            maxReach = Math.max(maxReach, i + nums[i]);
            // 已经可以到终点，提前结束
            if (maxReach >= nums.length - 1) return true;
        }
        return true;
    }
}

```



### ✅ 我的理解：

首先理解题意：从数组的第 0 个索引开始，每个元素值 `nums[i]` 表示在当前位置最多能跳跃的步数。也就是说，假设当前在索引 0，元素值是 2，那么你可以选择跳 1 步或 2 步。题目要求判断是否能够通过跳跃最终到达最后一个索引位置。

思路：核心思想是——只要我们跳的“最远可达范围”超过或等于最后一个索引，就一定可以到达终点。因此我们使用贪心思想，每次都尽量让自己走得更远。

具体做法：

1. 初始化变量 `maxReach = 0`，表示当前能到达的最远索引位置。
2. 遍历数组的每个索引 `i`：
    - 如果当前索引 `i` 已经超过 `maxReach`，说明前面跳不到这里，也就无法继续前进，直接返回 `false`。
    - 否则说明当前位置可达，就更新最远可达位置：`maxReach = Math.max(maxReach, i + nums[i])`。
    - 如果更新后发现 `maxReach` 已经大于或等于最后一个索引位置，说明一定能到达终点，直接返回 `true`。
3. 如果循环正常结束，说明遍历过程中都能走下去，也可以返回 `true`。

总结：
这题的关键点是“用贪心策略不断更新能到达的最远范围”，我们不关心每次跳几步，而是看整体的最大可达范围。只要当前索引在可达范围内，我们就能继续向前推进，否则就卡死无法到达。最终判断 `maxReach` 是否能覆盖最后一个索引即可。

首先理解题目意思：也就是从0索引位置开始走，先得到0索引下的元素值，这个元素值就是表示能够走多少步，步数范围就是 (0, 元素值]（理解是这样，但是此题贪心是追求更远），相当于就是假设为2，那么就可以走1步或者两步，然后尝试是否能到达最后一个索引位置；思路：总之就是只要走的范围最大超过或者等于最后一个索引位置就一定能到达；因此我们想到了贪心，在可达范围中不断更新最远，通过局部最优来实现整体最优也就是最远范围；首先；初始化最大最远返回位置索引为0，接着需要遍历数组来更新最远范围；接着需要判断当前遍历到的元素下的索引是否比最大范围还大，如果是这样，说明根本就达不到当前索引更别提到达最后一个索引位置，相反，如果最大范围索引超过当前遍历索引，那么就需要更新能到达的最远索引，在这个索引所处的位置加上元素值就是可走的索引最远来更新最远；如果最远可达已经超过了最后一个索引那么直接可以返回true，可以达到，反正就是可以达到走几步到达是最开始说的步数范围，遍历结束了，直接返回true，理论上不会实现，在内部实现了，作为兜底让函数返回

