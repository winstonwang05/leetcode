# 11.盛水最多的容器

题目的核心思想是：
数组中的每个元素代表一条竖线的高度，索引间的距离就是两条线之间的宽度。
我们要找到两条线，使得由它们与 x 轴组成的容器可以盛最多的水。
水的容量由下面公式决定：

> 面积 = 宽度 × 高度
>  其中高度取两条线中较短的那一条（因为高的那条线装水会“漏”）。

------

### 🧠 思路分析

我们想到用 **双指针** 来优化搜索：

- 左指针 `left` 从数组左端开始；
- 右指针 `right` 从数组右端开始；
- 每次计算当前容器的面积：
  `area = min(height[left], height[right]) * (right - left)`；
- 更新最大面积 `maxArea`。

关键问题是：

> 下一步该移动左指针还是右指针？

------

### 💡 贪心思想（短板效应）

由于水的高度取决于**较短的那条线**，
如果想尝试得到更大的面积，就必须**去掉短的那边**，看看能否找到更高的线。

- 若 `height[left] < height[right]`，说明左边是短板 → `left++`
- 否则右边是短板 → `right--`

这样移动不会错过最大值，因为：

- 宽度每次都在减小；
- 只有通过提高短边的高度，才有可能抵消宽度减小带来的损失。

------

### ⚙️ 代码实现（Java）

```
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int max = 0;

        while (left < right) {
            int h = Math.min(height[left], height[right]);
            int w = right - left;
            max = Math.max(max, h * w);

            // 移动短边
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return max;
    }
}
```

------

### 🧮 复杂度

- **时间复杂度：** O(n)
  每个元素最多访问一次；
- **空间复杂度：** O(1)
  仅用常数额外空间。

------

### 🎯 总结一句话

> “用双指针从两端向中间移动，每次淘汰短板，以局部最优（去短边）达到全局最优（最大盛水量）。”

首先题目的思路就是数组中的元素就代表高度，通过不同索引下的元素之前的距离*最小的元素值（因为取最高会漏）获取最大面积的过程；因此我们想到了双指针，分别定义左指针右移；右指针左移，但是要获取最大面积，如何实现呢？这里就想到了贪心，局部最优获取全局最优；我们该如何移动左右指针呢，可以通过短板效应，如果哪边短就移动哪一边，来获取最大面积，并不断更新最大；因为我们从头尾开始移动，如果遇到短板就移动，那么最大值不会被忽略；